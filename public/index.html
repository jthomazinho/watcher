<!doctype html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; connect-src 'self' https:; img-src 'self' data: https:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; font-src 'self' data:; frame-src 'self' https:;">
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Watcher Overlay</title>
	<style>
		html, body {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			background: transparent;
		}
		#root {
			position: fixed;
			top: 0; left: 0; right: 0; bottom: 0;
			background: transparent;
			pointer-events: none;
		}
		/* Top taskbar */
		.taskbar {
			position: absolute;
			top: 0; left: 0; right: 0;
			height: 48px;
			background: rgba(22, 22, 22, 0.5);
			color: #fff;
			display: flex;
			pointer-events: auto;
			align-items: center;
			gap: 12px;
			padding: 0 12px;
			box-sizing: border-box;
			pointer-events: auto; /* interactive */
			transition: transform 180ms ease-in-out, opacity 180ms ease-in-out;
		}
		.taskbar.hidden {
			transform: translateY(-100%);
			opacity: 0.2;
		}
		/* Small handle when hidden */
		.handle {
			position: absolute;
			top: 0;
			left: 50%;
			transform: translate(-50%, 0);
			width: 120px;
			height: 6px;
			background: rgba(22,22,22,0.7);
			border-bottom-left-radius: 6px;
			border-bottom-right-radius: 6px;
			pointer-events: auto;
			z-index: 2;
		}
		.handle.hidden { display: none; }
		/* Invisible hover trigger area at top */
		.hover-trigger {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			height: 12px;
			background: transparent;
			pointer-events: auto;
			z-index: 1;
		}
		.hover-trigger.hidden { display: none; }
		.taskbar { z-index: 3; }
		/* Webview area container */
		.webview-wrapper {
			position: absolute;
			top: 60px; /* below taskbar */
			left: 40px;
			right: 40px;
			bottom: 40px;
			border-radius: 12px;
			overflow: hidden;
			pointer-events: auto; /* interactive region */
			background: rgba(0,0,0,0.0); /* keep transparent; child controls visibility */
		}
		.webview-wrapper.hidden { display: none; pointer-events: none; }
		/* Buttons */
		button { background: #2f2f2f; color: #fff; border: 1px solid #444; padding: 6px 10px; border-radius: 6px; cursor: pointer; }
		button:hover { background: #3a3a3a; }
		.left-controls { display: flex; gap: 8px; margin-left: 100px; }
	</style>
</head>
<body>
	<div id="root">
		<div class="taskbar interactive hidden" id="taskbar">
			<div class="left-controls">
				<button id="btnTabDashboard">Dashboard</button>
				<button id="btnTabAgenda">Agenda</button>
				<button id="btnTabChatGPT">ChatGPT</button>
				<button id="btnTabSettings">Configurações</button>
				<button id="btnTabTrading">Trading</button>
				<button id="btnTabLib">Lib</button>
				<button id="btnTabQual">Qual</button>
			</div>
			<div style="flex:1"></div>
			<button id="btnDevTools" title="DevTools" style="margin-left:8px;">⚙</button>
			<button id="btnClose" title="Fechar" style="margin-left:8px; background:#8b1a1a;">✕</button>
		</div>
		<div class="handle interactive" id="handle"></div>
		<div class="hover-trigger interactive" id="hover-trigger"></div>
		<!-- Debug button -->
		<button id="debug-show" class="interactive" style="position:absolute; top:20px; right:20px; z-index:999; background:#f44; color:#fff; border:none; padding:4px 8px; opacity:0.9;">Show Menu</button>
		<!-- Debug log area -->
		<div id="debug-log" style="position:absolute; top:60px; right:20px; z-index:999; background:rgba(0,0,0,0.8); color:#0f0; font-family:monospace; font-size:10px; padding:4px; max-width:300px; max-height:200px; overflow:auto; pointer-events:none;"></div>
				<div class="webview-wrapper interactive hidden" id="webview-wrap">
				<webview id="dashboard" src="./dashboard.html" allowpopups disableblinkfeatures="Auxclick" preload="./webview-preload.js" webpreferences="contextIsolation=yes, nodeIntegration=no, devTools=yes" style="width:100%; height:100%; background: transparent;"></webview>
			</div>
	</div>

	<script>
		const { overlay } = window;
		const root = document.getElementById('root');
		async function updateWindowShape() {
			const rects = [];
			const nodes = document.querySelectorAll('.interactive');
			for (const el of nodes) {
				if (el.id === 'root') continue;
				const cs = getComputedStyle(el);
				if (cs.visibility === 'hidden' || cs.display === 'none') continue;
				const opacity = parseFloat(cs.opacity || '1');
				const bgAlpha = parseAlpha(cs.backgroundColor);
				const borderColors = [cs.borderTopColor, cs.borderRightColor, cs.borderBottomColor, cs.borderLeftColor];
				const borderWidths = [cs.borderTopWidth, cs.borderRightWidth, cs.borderBottomWidth, cs.borderLeftWidth].map(w => parseFloat(w) || 0);
				const borderAlpha = borderColors.some(c => parseAlpha(c) >= 0.5) && borderWidths.some(w => w > 0) ? 1 : 0;
				const hasImage = cs.backgroundImage && cs.backgroundImage !== 'none';
				const isWebview = el.tagName === 'WEBVIEW' || el.querySelector && el.querySelector('webview');
				const isOpaqueEnough = isWebview || hasImage || opacity >= 0.5 || bgAlpha >= 0.5 || borderAlpha >= 0.5;
				if (!isOpaqueEnough) continue;
				const r = el.getBoundingClientRect();
				if (r.width <= 0 || r.height <= 0) continue;
				const x0 = Math.round(r.left);
				const y0 = Math.round(r.top);
				const w = Math.round(r.width);
				const h = Math.round(r.height);
				const tl = parseFloat(cs.borderTopLeftRadius) || 0;
				const tr = parseFloat(cs.borderTopRightRadius) || 0;
				const br = parseFloat(cs.borderBottomRightRadius) || 0;
				const bl = parseFloat(cs.borderBottomLeftRadius) || 0;
				const rMax = Math.round(Math.min(w / 2, h / 2, Math.max(tl, tr, br, bl)));
				if (rMax > 0) {
					rects.push({ x: x0 + rMax, y: y0, width: Math.max(0, w - 2 * rMax), height: h });
					rects.push({ x: x0, y: y0 + rMax, width: rMax, height: Math.max(0, h - 2 * rMax) });
					rects.push({ x: x0 + w - rMax, y: y0 + rMax, width: rMax, height: Math.max(0, h - 2 * rMax) });
				} else {
					rects.push({ x: x0, y: y0, width: w, height: h });
				}
			}
			// ensure there's a small always-clickable band at the top when hidden
			if (hidden) {
				rects.push({ x: 0, y: 0, width: Math.round(window.innerWidth), height: 12 });
			}
			await overlay.setShape(rects);
		}
		const taskbar = document.getElementById('taskbar');
		const handle = document.getElementById('handle');
		const hoverTrigger = document.getElementById('hover-trigger');
		const wrap = document.getElementById('webview-wrap');
		const webview = document.getElementById('dashboard');
		const btnTabDashboard = document.getElementById('btnTabDashboard');
		const btnTabAgenda = document.getElementById('btnTabAgenda');
		const btnTabChatGPT = document.getElementById('btnTabChatGPT');
		const btnTabSettings = document.getElementById('btnTabSettings');
		const btnTabTrading = document.getElementById('btnTabTrading');
		const btnTabLib = document.getElementById('btnTabLib');
		const btnTabQual = document.getElementById('btnTabQual');
		const btnClose = document.getElementById('btnClose');
		const btnDevTools = document.getElementById('btnDevTools');
		let smartMode = true;

		let hidden = false;
		let alwaysOnTop = true;
		let hideTimer = null;
		function scheduleAutoHide() {
			if (hideTimer) clearTimeout(hideTimer);
			hideTimer = setTimeout(() => { if (!hidden) hideTaskbar(); }, 5000);
		}
		function cancelAutoHide() { if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; } }
		const getInteractiveRoots = () => Array.from(document.querySelectorAll('.interactive'));
		function isPointInRect(x, y, r) { return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom; }
		function isInInteractiveRect(x, y) {
			for (const el of getInteractiveRoots()) {
				const cs = getComputedStyle(el);
				if (cs.visibility === 'hidden' || cs.display === 'none' || cs.pointerEvents === 'none' || parseFloat(cs.opacity || '1') === 0) continue;
				const r = el.getBoundingClientRect();
				if (r.width <= 0 || r.height <= 0) continue;
				if (isPointInRect(x, y, r)) return true;
			}
			return false;
		}

		function parseAlpha(color) {
			if (!color) return 0;
			if (color === 'transparent') return 0;
			const m = color.match(/rgba?\(([^)]+)\)/);
			if (!m) return 0;
			const parts = m[1].split(',').map(s => s.trim());
			if (parts.length === 4) return Math.max(0, Math.min(1, parseFloat(parts[3]) || 0));
			return 1;
		}

		function hasOpaqueVisual(el) {
			const cs = getComputedStyle(el);
			if (cs.visibility === 'hidden' || cs.display === 'none') return false;
			const opacity = parseFloat(cs.opacity || '1');
			// Regra: componentes são 0.5 ou 0.0. Só consideramos opaco se >= 0.5
			if (opacity < 0.5) return false;
			if (cs.backgroundImage !== 'none') return true;
			if (parseAlpha(cs.backgroundColor) >= 0.5) return true;
			const widths = [cs.borderTopWidth, cs.borderRightWidth, cs.borderBottomWidth, cs.borderLeftWidth].map(w => parseFloat(w) || 0);
			if (widths.some(w => w > 0)) {
				const colors = [cs.borderTopColor, cs.borderRightColor, cs.borderBottomColor, cs.borderLeftColor];
				if (colors.some(c => parseAlpha(c) >= 0.5)) return true;
			}
			return false;
		}

		function isOpaqueAtPoint(x, y) {
			// Fast path: any interactive box region counts as opaque regardless de alpha visual
			if (isInInteractiveRect(x, y)) return true;
			const stack = document.elementsFromPoint(x, y);
			if (!stack || stack.length === 0) return false;
			if (stack.some(el => el.tagName === 'WEBVIEW')) return true;
			for (const el of stack) {
				if (el === document.documentElement || el === document.body || el.id === 'root') continue;
				if (hasOpaqueVisual(el)) return true;
			}
			return false;
		}

		function isTransparentClick(x, y) {
			return !isOpaqueAtPoint(x, y);
		}

		let lastOpaque = null;
		function updateMouseThroughAt(x, y) {
			if (!smartMode) return; // em modo clique real, shape cobre toda a janela
			const transparent = isTransparentClick(x, y);
			const opaque = !transparent;
			if (opaque !== lastOpaque) {
				lastOpaque = opaque;
			}
		}

		function showTaskbar() {
			debugger; // Breakpoint aqui quando DevTools estiver aberto
			log('showTaskbar called');
			hidden = false;
			taskbar.classList.remove('hidden');
			handle.classList.add('hidden');
			hoverTrigger.classList.add('hidden');
			updateWindowShape();
			cancelAutoHide();
			scheduleAutoHide();
		}
		function hideTaskbar() {
			log('hideTaskbar called');
			hidden = true;
			taskbar.classList.add('hidden');
			handle.classList.remove('hidden');
			hoverTrigger.classList.remove('hidden');
			updateWindowShape();
			cancelAutoHide();
		}

		// Hover no handle reexibe a taskbar
		handle.addEventListener('mouseenter', () => {
			console.log('handle mouseenter, hidden:', hidden);
			if (hidden) showTaskbar();
		});
		// Hover trigger area também reexibe
		hoverTrigger.addEventListener('mouseenter', () => {
			console.log('hoverTrigger mouseenter, hidden:', hidden);
			if (hidden) showTaskbar();
		});
		hoverTrigger.addEventListener('mouseover', () => {
			console.log('hoverTrigger mouseover, hidden:', hidden);
			if (hidden) showTaskbar();
		});
		taskbar.addEventListener('mouseenter', cancelAutoHide);
		taskbar.addEventListener('mouseleave', scheduleAutoHide);
		// Tabs do topo controlam o conteúdo do webview
		function ensureDashboardLoaded() {
			return new Promise((resolve) => {
				if (!webview) return resolve(false);
				try {
					const currentUrl = webview.getURL && webview.getURL();
					if (currentUrl && currentUrl !== 'about:blank') return resolve(true);
					webview.addEventListener('did-finish-load', () => resolve(true), { once: true });
					(async () => {
						try {
							const preloadPath = await overlay.getAssetFilePath('public/webview-preload.js');
							const pageUrl = await overlay.getAssetFileUrl('public/dashboard.html');
							if (preloadPath) webview.setAttribute('preload', preloadPath);
							if (pageUrl) webview.src = pageUrl; else webview.src = './dashboard.html';
						} catch {
							webview.src = './dashboard.html';
						}
					})();
				} catch { resolve(false); }
			});
		}
		async function selectTab(name) {
			if (!webview) return;
			await ensureDashboardLoaded();
			const code = `window.showSection && window.showSection(${JSON.stringify(name)});`;
			webview.executeJavaScript(code).catch(()=>{});
		}
		btnTabDashboard.addEventListener('click', async () => {
			wrap.classList.remove('hidden');
			// full width
			wrap.style.left = '40px';
			wrap.style.right = '40px';
			await ensureDashboardLoaded();
			updateWindowShape();
		});
		btnTabAgenda.addEventListener('click', async () => {
			wrap.classList.remove('hidden');
			// full width
			wrap.style.left = '40px';
			wrap.style.right = '40px';
			await ensureDashboardLoaded();
			selectTab('calendar');
			updateWindowShape();
		});
		// TODO: mover conteúdo de Agenda para a página própria de Agenda
		btnTabChatGPT.addEventListener('click', async () => {
			wrap.classList.remove('hidden');
			// left half of the screen
			wrap.style.left = '40px';
			wrap.style.right = '50%';
			await ensureDashboardLoaded();
			selectTab('chatgpt');
			updateWindowShape();
		});
		btnTabSettings.addEventListener('click', async () => {
			wrap.classList.remove('hidden');
			wrap.style.left = '40px';
			wrap.style.right = '40px';
			await ensureDashboardLoaded();
			selectTab('settings');
			updateWindowShape();
		});
		btnTabTrading.addEventListener('click', async () => {
			wrap.classList.remove('hidden');
			wrap.style.left = '40px';
			wrap.style.right = '40px';
			await ensureDashboardLoaded();
			selectTab('trading');
			updateWindowShape();
		});
		btnTabLib.addEventListener('click', async () => {
			wrap.classList.remove('hidden');
			wrap.style.left = '40px';
			wrap.style.right = '40px';
			await ensureDashboardLoaded();
			selectTab('lib');
			updateWindowShape();
		});
		btnTabQual.addEventListener('click', async () => {
			wrap.classList.remove('hidden');
			wrap.style.left = '40px';
			wrap.style.right = '40px';
			await ensureDashboardLoaded();
			selectTab('qual');
			updateWindowShape();
		});
		btnClose.addEventListener('click', async (e) => {
			e.preventDefault();
			e.stopPropagation();
			try { await overlay.quit(); } catch {}
			// Fallback se algo impedir o IPC
			setTimeout(() => { try { window.close(); } catch {} }, 200);
		});
		btnDevTools.addEventListener('click', async () => {
			try {
				// ensure webview is ready
				if (webview.isLoading && webview.isLoading()) { webview.addEventListener('did-finish-load', () => btnDevTools.click(), { once: true }); return; }
				const id = webview.getWebContentsId && webview.getWebContentsId();
				if (!id) { try { if (webview.isDevToolsOpened && webview.isDevToolsOpened()) webview.closeDevTools(); else webview.openDevTools({ mode: 'right' }); window.__webviewDevtoolsOpen = webview.isDevToolsOpened && webview.isDevToolsOpened(); } catch {} ; return; }
				await overlay.toggleWebviewDevTools({ webContentsId: id, dock: 'right' });
			} catch {}
		});

		// Ajuste de shape quando DevTools abre/fecha para manter clique no webview e devtools dockado
		setInterval(() => {
			if (window.__webviewDevtoolsOpen) {
				// expandir shape para toda a janela (evita área clicável reduzida)
				try {
					wrap.classList.remove('hidden');
					updateWindowShape();
				} catch {}
			}
		}, 500);

		function onPointerMove(e) {
			updateMouseThroughAt(e.clientX, e.clientY);
			// Trigger taskbar when cursor is near the top
			if (hidden && e.clientY <= 12) {
				console.log('Cursor at top, y:', e.clientY);
				showTaskbar();
			}
		}
		document.addEventListener('mousemove', onPointerMove);
		window.addEventListener('resize', updateWindowShape);
		new ResizeObserver(updateWindowShape).observe(document.body);
		
		// Debug button
		document.getElementById('debug-show').addEventListener('click', () => {
			log('Debug button clicked, hidden was:' + hidden);
			showTaskbar();
		});
		
		// Ensure proper initial state
		hidden = true;
		taskbar.classList.add('hidden');
		handle.classList.remove('hidden');
		hoverTrigger.classList.remove('hidden');
		updateWindowShape();
		
		console.log('Initial state set, hover trigger visible:', !hoverTrigger.classList.contains('hidden'));
		
		// Debug logging to screen
		const debugLog = document.getElementById('debug-log');
		function log(msg) {
			console.log(msg);
			if (debugLog) {
				debugLog.innerHTML += new Date().toLocaleTimeString() + ': ' + msg + '<br>';
				debugLog.scrollTop = debugLog.scrollHeight;
			}
		}
		log('App initialized, hidden=' + hidden);
		
		// Make log function global
		window.log = log;

		// Fallback polling when window is ignoring mouse events
		let polling = false;
		async function pollCursor() {
			if (polling) return;
			polling = true;
			while (true) {
				try {
					const { x, y } = await overlay.getLocalCursor();
					updateMouseThroughAt(x, y);
					await new Promise(r => setTimeout(r, 16));
				} catch {
					await new Promise(r => setTimeout(r, 50));
				}
			}
		}
		// Initial evaluation ASAP + force one more after first paint
		(async () => {
			try {
				await new Promise(r => requestAnimationFrame(r));
				const { x, y } = await overlay.getLocalCursor();
				updateMouseThroughAt(x, y);
			} finally {
				pollCursor();
			}
		})();

		// Recebe sinal do main para voltar ao modo inteligente
		window.__overlaySmartMode = true;
		const smartModeSetter = setInterval(() => {
			if (window.__overlaySmartMode) {
				smartMode = true;
				window.__overlaySmartMode = false;
				updateWindowShape();
			}
		}, 200);
	</script>
</body>
</html> 